//stamp/math/vector.h

//all xml documentation is generated by AI, must be revised

#pragma once
#ifndef STAMP_MATH_vector_H
#define STAMP_MATH_vector_H

// Copyright 2025 Elijah Clark, Stamparkour
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// provides short names for vector types and functions
// #define STAMP_MATH_vector_SHORT_NAMES

// makes all comparison operators prefer equal_aprox
// #define STAMP_MATH_vector_EQUAL_APROX

//optional headers: <iostream> <string>
#include <stamp/math/define.h>

STAMP_MATH_NAMESPACE_BEGIN

/// <summary>Primary fixed-size vector template declaration.
/// Represents a D-dimensional vector of elements of type T.
/// Use specializations for common dimensions (2,3,4) which provide named members.</summary>
/// <typeparam name="T">Element type stored in the vector. Defaults to STAMP_DEFAULT_FLOATINGPOINT.</typeparam>
/// <typeparam name="D">Number of dimensions (compile-time constant). Defaults to 2.</typeparam>
template<typename T = STAMP_DEFAULT_FLOATINGPOINT, size_t D = 2>
struct vector;
STAMP_TEMPLATE_ALL_QUANTITY_TEMPLATED(vector, template<size_t D = 2>, COMMA D);

/// <summary>Alias for 2-dimensional vector type.</summary>
/// <typeparam name="T">Element type; defaults to STAMP_DEFAULT_FLOATINGPOINT.</typeparam>
template <typename T = STAMP_DEFAULT_FLOATINGPOINT>
using vector2 = vector<T, 2>;
/// <summary>Alias for 3-dimensional vector type.</summary>
/// <typeparam name="T">Element type; defaults to STAMP_DEFAULT_FLOATINGPOINT.</typeparam>
template <typename T = STAMP_DEFAULT_FLOATINGPOINT>
using vector3 = vector<T, 3>;
/// <summary>Alias for 4-dimensional vector type.</summary>
/// <typeparam name="T">Element type; defaults to STAMP_DEFAULT_FLOATINGPOINT.</typeparam>
template <typename T = STAMP_DEFAULT_FLOATINGPOINT>
using vector4 = vector<T, 4>;

STAMP_TEMPLATE_ALL_QUANTITY(vector2);
STAMP_TEMPLATE_ALL_QUANTITY(vector3);
STAMP_TEMPLATE_ALL_QUANTITY(vector4);

#ifdef STAMP_MATH_vector_SHORT_NAMES
/// <summary>Short alias for vectors when STAMP_MATH_vector_SHORT_NAMES is enabled.</summary>
template <typename T = STAMP_DEFAULT_FLOATINGPOINT, size_t D = 2>
using vec = vector<T, D>;
STAMP_TEMPLATE_ALL_QUANTITY_TEMPLATED(vec, template<size_t D = 2>, COMMA D);

/// <summary>Short alias for 2D vectors when STAMP_MATH_vector_SHORT_NAMES is enabled.</summary>
template <typename T = STAMP_DEFAULT_FLOATINGPOINT>
using vec2 = vector2<T = STAMP_DEFAULT_FLOATINGPOINT>;
STAMP_TEMPLATE_ALL_QUANTITY(vec2);

/// <summary>Short alias for 3D vectors when STAMP_MATH_vector_SHORT_NAMES is enabled.</summary>
template <typename T = STAMP_DEFAULT_FLOATINGPOINT>
using vec3 = vector2<T = STAMP_DEFAULT_FLOATINGPOINT>;
STAMP_TEMPLATE_ALL_QUANTITY(vec3);

/// <summary>Short alias for 4D vectors when STAMP_MATH_vector_SHORT_NAMES is enabled.</summary>
template <typename T = STAMP_DEFAULT_FLOATINGPOINT>
using vec4 = vector2<T = STAMP_DEFAULT_FLOATINGPOINT>;
STAMP_TEMPLATE_ALL_QUANTITY(vec4);
#endif

/// <summary>CRTP base class providing common accessors and conversions for vectors.
/// Concrete vector types derive from this to gain conversion operators, pointer conversions,
/// boolean conversion and iterator/access helpers.</summary>
/// <typeparam name="V">Concrete vector type inheriting this base (CRTP).</typeparam>
/// <typeparam name="T">Element type stored in the concrete vector.</typeparam>
/// <typeparam name="D">Number of dimensions of the concrete vector.</typeparam>
template<typename V, typename T, size_t D>
struct vector_Base {
	/// <summary>Implicit conversion to a vector with same dimension but different element type.</summary>
	template<typename T1> operator vector<T1, D>() const noexcept;
	/// <summary>Implicit conversion to a vector with possibly different dimensions and element type.
/// Extra components are zero-initialized in the target.</summary>
	template<typename T1, size_t D1> operator vector<T1, D1>() const noexcept;
	/// <summary>Const pointer conversion to contiguous element storage.</summary>
	explicit operator const T* () const noexcept;
	/// <summary>Mutable pointer conversion to contiguous element storage.</summary>
	explicit operator T* () noexcept;
	/// <summary>Boolean conversion: returns true if all components are non-zero.</summary>
	explicit operator bool() const noexcept;

	/// <summary>Default constructor enabled when T satisfies Field concept.</summary>
	constexpr vector_Base() requires Field<T> {}

	/// <summary>Compile-time indexed mutable accessor (returns reference to element Q).</summary>
	/// <typeparam name="Q">Compile-time index into the vector (0-based).</typeparam>
	template<size_t Q>
	auto& get();
	/// <summary>Compile-time indexed const accessor (returns const reference to element Q).</summary>
	/// <typeparam name="Q">Compile-time index into the vector (0-based).</typeparam>
	template<size_t Q>
	const auto& get() const;
	/// <summary>Begin iterator (mutable) over underlying storage.</summary>
	auto begin();
	/// <summary>Begin iterator (const) over underlying storage.</summary>
	auto cbegin() const;
	/// <summary>End iterator (mutable) over underlying storage.</summary>
	auto end();
	/// <summary>End iterator (const) over underlying storage.</summary>
	auto cend() const;
};

/// <summary>Generic D-dimensional vector storage and simple constructors.
/// This specialization backs storage with a raw array 'V'.</summary>
/// <typeparam name="T">Element type.</typeparam>
/// <typeparam name="D">Number of dimensions.</typeparam>
template<typename T, size_t D>
struct vector : public vector_Base<vector<T, D>, T, D> {
	using member_type = T;
	constexpr static size_t dimensions = D;

	/// <summary>Contiguous storage for components.</summary>
	T V[D] = {};
	/// <summary>Default constructor: leaves elements value-initialized.</summary>
	vector() noexcept {}
	/// <summary>Construct with all components set to the same scalar value.</summary>
	vector(T x) noexcept {
		for (int i = 0; i < dimensions; i++) V[i] = x;
	}
};

/// <summary>2D vector specialization with named members x, y and common directional constants.</summary>
/// <typeparam name="T">Element type.</typeparam>
template <typename T>
struct vector<T, 2> : public vector_Base<vector<T, 2>, T, 2> {
	using member_type = T;
	constexpr static size_t dimensions = 2;

	union {
		/// <summary>Contiguous storage for components [x, y].</summary>
		T V[2] = {};
		/// <summary>Named components for convenience.</summary>
		struct { T x, y; };
	};

	/// <summary>Default constructor.</summary>
	vector() noexcept {}
	/// <summary>Fill both components with the same value.</summary>
	vector(T x) noexcept : x(x), y(x) {}
	/// <summary>Construct from explicit x and y values.</summary>
	vector(T x, T y)	noexcept : x(x), y(y) {}

	/// <summary>vector whose components are all 1.</summary>
	const static vector2<T> UNIT;
	/// <summary>Unit vector in +X direction.</summary>
	const static vector2<T> UP;
	/// <summary>Unit vector in -X direction.</summary>
	const static vector2<T> DOWN;
	/// <summary>Unit vector in +Y direction.</summary>
	const static vector2<T> RIGHT;
	/// <summary>Unit vector in -Y direction.</summary>
	const static vector2<T> LEFT;
};

/// <summary>3D vector specialization with named members x,y,z and convenience constructors/constants.</summary>
/// <typeparam name="T">Element type.</typeparam>
template <typename T>
struct vector<T, 3> : public vector_Base<vector<T, 3>, T, 3> {
	using member_type = T;
	constexpr static size_t dimensions = 3;
	union {
		/// <summary>Contiguous storage for components [x, y, z].</summary>
		T V[3] = {};
		/// <summary>Named components for convenience.</summary>
		struct { T x, y, z; };
	};

	/// <summary>Default constructor.</summary>
	vector() noexcept {}
	/// <summary>Fill all components with the same scalar value.</summary>
	vector(T x) noexcept : x(x), y(x), z(x) {}
	/// <summary>Construct from three scalars (x,y,z).</summary>
	vector(T x, T y, T z)				noexcept : x(x), y(y), z(z) {}
	/// <summary>Construct from 2D vector + z component.</summary>
	vector(const vector2<T>& a, T z)	noexcept : x(a.x), y(a.y), z(z) {}
	/// <summary>Construct from x scalar and a 2D vector for (y,z).</summary>
	vector(T x, const vector2<T>& a)	noexcept : x(x), y(a.x), z(a.y) {}

	/// <summary>vector whose components are all 1.</summary>
	const static vector3<T> UNIT;
	/// <summary>Unit vector in +X direction.</summary>
	const static vector3<T> UP;
	/// <summary>Unit vector in -X direction.</summary>
	const static vector3<T> DOWN;
	/// <summary>Unit vector in +Y direction.</summary>
	const static vector3<T> RIGHT;
	/// <summary>Unit vector in -Y direction.</summary>
	const static vector3<T> LEFT;
	/// <summary>Unit vector in +Z direction (forward).</summary>
	const static vector3<T> FORWARD;
	/// <summary>Unit vector in -Z direction (back).</summary>
	const static vector3<T> BACK;
};

/// <summary>4D vector specialization with named members x,y,z,w and many convenience constructors/constants.</summary>
/// <typeparam name="T">Element type.</typeparam>
template <typename T>
struct vector<T, 4> : public vector_Base<vector<T, 4>, T, 4> {
	using member_type = T;
	constexpr static size_t dimensions = 4;
	union {
		/// <summary>Contiguous storage for components [x, y, z, w].</summary>
		T V[4] = {};
		/// <summary>Named components for convenience.</summary>
		struct { T x, y, z, w; };
	};

	/// <summary>Default constructor.</summary>
	vector() noexcept {}
	/// <summary>Fill all components with the same scalar value.</summary>
	vector(T x) noexcept : x(x), y(x), z(x), w(x) {}
	/// <summary>Two-component constructor (maps x,y; z and w are set from provided values in this overload's initializer).</summary>
	vector(T x, T y)									noexcept : x(x), y(y), z(x), w(y) {}
	/// <summary>Construct from four scalars (x,y,z,w).</summary>
	vector(T x, T y, T z, T w)						noexcept : x(x), y(y), z(z), w(w) {}
	/// <summary>Construct from 2D vector + z + w.</summary>
	vector(const vector2<T>& a, T z, T w)				noexcept : x(a.x), y(a.y), z(z), w(w) {}
	/// <summary>Construct from x + 2D vector + w.</summary>
	vector(T x, const vector2<T>& a, T w)				noexcept : x(x), y(a.x), z(a.y), w(w) {}
	/// <summary>Construct from x, y + 2D vector.</summary>
	vector(T x, T y, const vector2<T>& a)				noexcept : x(x), y(y), z(a.x), w(a.y) {}
	/// <summary>Construct from two 2D vectors (first maps to x,y; second maps to z,w).</summary>
	vector(const vector2<T>& a, const vector2<T>& b)	noexcept : x(a.x), y(a.y), z(b.x), w(b.y) {}
	/// <summary>Construct from 3D vector + w.</summary>
	vector(const vector3<T>& a, T w)					noexcept : x(a.x), y(a.y), z(a.z), w(w) {}
	/// <summary>Construct from x + 3D vector (remaining components mapped accordingly).</summary>
	vector(T x, const vector3<T>& a)					noexcept : x(x), y(a.x), z(a.y), w(a.z) {}

	/// <summary>vector whose components are all 1.</summary>
	const static vector4<T> UNIT;
	/// <summary>Unit vector in +X direction.</summary>
	const static vector4<T> UP;
	/// <summary>Unit vector in -X direction.</summary>
	const static vector4<T> DOWN;
	/// <summary>Unit vector in +Y direction.</summary>
	const static vector4<T> RIGHT;
	/// <summary>Unit vector in -Y direction.</summary>
	const static vector4<T> LEFT;
	/// <summary>Unit vector in +Z direction (forward).</summary>
	const static vector4<T> FORWARD;
	/// <summary>Unit vector in -Z direction (back).</summary>
	const static vector4<T> BACK;
	/// <summary>Unit vector in +W direction (ana).</summary>
	const static vector4<T> ANA;
	/// <summary>Unit vector in -W direction (kana).</summary>
	const static vector4<T> KANA;
};


//////////////////////////////////////////////////////////////////////////////
// Operators and algorithms - declarations
//////////////////////////////////////////////////////////////////////////////

/// <summary>Component-wise addition of two vectors producing a vector of common_type elements.</summary>
template <size_t D, typename T1, typename T2, typename TR = std::common_type_t<T1, T2>>	vector<TR, D>	operator	+	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise subtraction of two vectors producing a vector of common_type elements.</summary>
template <size_t D, typename T1, typename T2, typename TR = std::common_type_t<T1, T2>>	vector<TR, D>	operator	-	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise multiplication of two vectors producing a vector of common_type elements.</summary>
template <size_t D, typename T1, typename T2, typename TR = std::common_type_t<T1, T2>>	vector<TR, D>	operator	*	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise division of two vectors producing a vector of common_type elements.</summary>
template <size_t D, typename T1, typename T2, typename TR = std::common_type_t<T1, T2>>	vector<TR, D>	operator	/	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise addition assignment.</summary>
template <size_t D, typename T1, typename T2>	vector<T1, D>& operator	+=	(vector<T1, D>& a, const vector<T2, D>& b)			noexcept;
/// <summary>Component-wise subtraction assignment.</summary>
template <size_t D, typename T1, typename T2>	vector<T1, D>& operator	-=	(vector<T1, D>& a, const vector<T2, D>& b)			noexcept;
/// <summary>Component-wise multiplication assignment.</summary>
template <size_t D, typename T1, typename T2>	vector<T1, D>& operator	*=	(vector<T1, D>& a, const vector<T2, D>& b)			noexcept;
/// <summary>Component-wise division assignment.</summary>
template <size_t D, typename T1, typename T2>	vector<T1, D>& operator	/=	(vector<T1, D>& a, const vector<T2, D>& b)			noexcept;
/// <summary>Component-wise equality comparison producing a boolean vector.</summary>
template <size_t D, typename T1, typename T2>	vector<bool, D>	operator	==	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Logical negation of equality (uses operator==).</summary>
template <size_t D, typename T1, typename T2>	bool			operator	!=	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise greater-than comparison producing a boolean vector.</summary>
template <size_t D, typename T1, typename T2>	vector<bool, D>	operator	>	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise less-than comparison producing a boolean vector.</summary>
template <size_t D, typename T1, typename T2>	vector<bool, D>	operator	<	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise greater-or-equal comparison producing a boolean vector.</summary>
template <size_t D, typename T1, typename T2>	vector<bool, D>	operator	>=	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise less-or-equal comparison producing a boolean vector.</summary>
template <size_t D, typename T1, typename T2>	vector<bool, D>	operator	<=	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise logical AND producing a boolean vector.</summary>
template <size_t D, typename T1, typename T2>	vector<bool, D>	operator	&&	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Component-wise logical OR producing a boolean vector.</summary>
template <size_t D, typename T1, typename T2>	vector<bool, D>	operator	||	(const vector<T1, D>& a, const vector<T2, D>& b)	noexcept;
/// <summary>Unary negation: negates each component.</summary>
template <size_t D, typename T>	vector<T, D>	operator	-	(const vector<T, D>& v)												noexcept;
/// <summary>Component-wise logical-not producing a boolean vector.</summary>
template <size_t D, typename T>	vector<bool, D>	operator	~	(const vector<T, D>& v)												noexcept;
/// <summary>Logical-not of the whole vector: true when all components are false/zero.</summary>
template <size_t D, typename T>	bool			operator	!	(const vector<T, D>& v)												noexcept;


STAMP_OPERATOR_ALL_QUANTITY_TEMPLATED(vector<T1 COMMA D>, T2, vector<T2 COMMA D>, vector<TR COMMA D>, template <size_t D COMMA typename T1 COMMA typename T2>, template <size_t D COMMA typename T1 COMMA typename T2 COMMA typename TR = std::common_type_t<T1 COMMA T2>>);
STAMP_COMP_OPERATOR_ALL_QUANTITY_TEMPLATED(vector<T1 COMMA D>, T2, vector<T2 COMMA D>, vector<bool COMMA D>, template <size_t D COMMA typename T1 COMMA typename T2>);

/// <summary>2D cross product producing scalar equal to the z-component of the 3D cross product.</summary>
template <typename T> T 						cross(const vector2<T>& a, const vector2<T>& b)		noexcept;
/// <summary>3D cross product producing a vector3 perpendicular to both inputs.</summary>
template <typename T> vector3<T>				cross(const vector3<T>& a, const vector3<T>& b)		noexcept;
/// <summary>Logical-and over components (returns true if every component is non-zero).</summary>
template <typename T, size_t D> bool			_and(const vector<T, D>& v) 						noexcept;
/// <summary>Logical-or over components (returns true if any component is non-zero).</summary>
template <typename T, size_t D> bool			_or(const vector<T, D>& v) 							noexcept;
/// <summary>Sum of all components.</summary>
template <typename T, size_t D> T				summation(const vector<T, D>& v) 					noexcept;
/// <summary>vector magnitude (length).</summary>
template <typename T, size_t D> T 				magnitude(const vector<T, D>& v)					noexcept;
/// <summary>Squared magnitude (length^2) of a vector.</summary>
template <typename T, size_t D> T 				magnitude2(const vector<T, D>& v) 					noexcept;
/// <summary>Normalized vector (unit length). Returns zero vector when input has zero length.</summary>
template <typename T, size_t D> vector<T, D>	normal(const vector<T, D>& v) 						noexcept;
/// <summary>Dot product of two vectors.</summary>
template <typename T, size_t D> T				dot(const vector<T, D>& a, const vector<T, D>& b)	noexcept;
#ifdef STAMP_MATH_vector_SHORT_NAMES
/// <summary>Short alias for summation().</summary>
template <typename T, size_t D> T				sum(const vector<T, D>& v)	noexcept;
/// <summary>Short alias for magnitude().</summary>
template <typename T, size_t D> T 				mag(const vector<T, D>& v)	noexcept;
/// <summary>Short alias for magnitude2().</summary>
template <typename T, size_t D> T 				mag2(const vector<T, D>& v)	noexcept;
/// <summary>Short alias for normal().</summary>
template <typename T, size_t D> vector<T, D>	norm(const vector<T, D>& v)	noexcept;
#endif

/// <summary>Component-wise approximate equality using scalar equal_aprox for each component.</summary>
template <size_t D, typename T1, typename T2> vector<bool, D>	equal_aprox(const vector<T1, D>& a, const vector<T2, D>& b);

#if defined(STAMP_MATH_ALGORITHM_SHORT_NAMES) || defined(STAMP_MATH_vector_SHORT_NAMES)
/// <summary>Short alias for equal_aprox when short names are enabled.</summary>
template <size_t D, typename T1, typename T2> vector<bool, D> eq_e(const vector<T1, D>& a, const vector<T2, D>& b);
#endif
#ifdef STAMP_OSTREAM_HEADER_INCLUDED
/// <summary>Stream insertion operator for vectors; prints components in parentheses separated by commas.</summary>
template <typename T, size_t D> std::ostream& operator <<(std::ostream& stream, const vector<T, D>& v);
#endif
#ifdef STAMP_STRING_HEADER_INCLUDED
/// <summary>Serialize vector to std::string in human readable form (components in parentheses).</summary>
template <typename T, size_t D> std::string to_string(const vector<T, D>& v);
#endif

// Definitions

//----------- vector Base Logic ----------

template<typename V, typename T, size_t D>
template<typename T1, size_t D1> 
inline vector_Base<V, T, D>::operator vector<T1, D1>() const noexcept {
	auto self = static_cast<const V*>(this);
	vector<T1, D1> o;
	for (size_t i = 0; i < D1; ++i)
		o.V[i] = (i < V::dimensions ? static_cast<T1>(self->V[i]) : 0);
	return o;
}
template<typename V, typename T, size_t D>
template<typename T1>
inline vector_Base<V, T, D>::operator vector<T1, D>() const noexcept {
	auto self = static_cast<const V*>(this);
	vector<T1, D> o;
	for (size_t i = 0; i < D; ++i)
		o.V[i] = static_cast<T1>(self->V[i]);
	return o;
}
template<typename V, typename T, size_t D>
inline vector_Base<V, T, D>::operator const T* () const noexcept {
	auto self = static_cast<const V*>(this);
	return self->V;
}
template<typename V, typename T, size_t D>
inline vector_Base<V, T, D>::operator T* () noexcept {
	auto self = static_cast<V*>(this);
	return self->V;
}
template<typename V, typename T, size_t D>
inline vector_Base<V, T, D>::operator bool() const noexcept {
	auto self = static_cast<const V*>(this);
	for (size_t i = 0; i < D; ++i) if (!self->V[i]) return false; return true;
}
template<typename V, typename T, size_t D>
template<size_t Q>
inline auto& vector_Base<V, T, D>::get() {
	auto self = static_cast<const V*>(this);
	return std::get<Q>(self->V);
}
template<typename V, typename T, size_t D>
template<size_t Q>
inline const auto& vector_Base<V, T, D>::get() const {
	auto self = static_cast<const V*>(this);
	return std::get<Q>(self->V);
}
template<typename V, typename T, size_t D>
inline auto vector_Base<V, T, D>::begin() {
	auto self = static_cast<V*>(this);
	return std::begin(self->V);
}
template<typename V, typename T, size_t D>
inline auto vector_Base<V, T, D>::cbegin() const {
	auto self = static_cast<const V*>(this);
	return std::begin(self->V);
}
template<typename V, typename T, size_t D>
inline auto vector_Base<V, T, D>::end() {
	auto self = static_cast<V*>(this);
	return std::end(self->V);
}
template<typename V, typename T, size_t D>
inline auto vector_Base<V, T, D>::cend() const {
	auto self = static_cast<const V*>(this);
	return std::end(self->V);
}
// ------------ Generic Logic ------------


template <size_t D, typename T1, typename T2, typename TR>
inline vector<TR, D> operator+(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<TR, D> o;
	for(size_t i = 0; i < D; ++i) o.V[i] = static_cast<TR>(a.V[i] + b.V[i]);
	return o;
}
template <size_t D, typename T1, typename T2>
inline vector<T1, D>& operator+=(vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	for (size_t i = 0; i < D; ++i) a.V[i] += b.V[i];
	return a;
}
template <size_t D, typename T1, typename T2, typename TR>
inline vector<TR, D> operator-(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<TR, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = static_cast<TR>(a.V[i] - b.V[i]);
	return o;
}
template <size_t D, typename T1, typename T2>
inline vector<T1, D>& operator-=(vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	for (size_t i = 0; i < D; ++i) a.V[i] -= b.V[i];
	return a;
}
template <size_t D, typename T1, typename T2, typename TR>
inline vector<TR, D> operator*(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<TR, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = static_cast<TR>(a.V[i] * b.V[i]);
	return o;
}
template <size_t D, typename T1, typename T2>
inline vector<T1, D>& operator*=(vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	for (size_t i = 0; i < D; ++i) a.V[i] *= b.V[i];
	return a;
}
template <size_t D, typename T1, typename T2, typename TR>
inline vector<TR, D> operator/(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<TR, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = static_cast<TR>(a.V[i] / b.V[i]);
	return o;
}
template <size_t D, typename T1, typename T2>
inline vector<T1, D>& operator/=(vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	for (size_t i = 0; i < D; ++i) a.V[i] /= b.V[i];
	return a;
}
#ifdef STAMP_MATH_vector_EQUAL_APROX
template <size_t D, typename T1, typename T2>
inline vector2<bool> operator==(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	return equal_aprox(*this, b);
}
#else
template <size_t D, typename T1, typename T2>
inline vector<bool, D> operator==(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<bool, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = a.V[i] == b.V[i];
	return o;
}
#endif
template <size_t D, typename T1, typename T2>
inline bool operator!=(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	return !(a == b);
}
template <size_t D, typename T1, typename T2>
inline vector<bool, D> operator>(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<bool, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = a.V[i] > b.V[i];
	return o;
}
template <size_t D, typename T1, typename T2>
inline vector<bool, D> operator<(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<bool, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = a.V[i] < b.V[i];
	return o;
}
template <size_t D, typename T1, typename T2>
inline vector<bool, D> operator>=(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<bool, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = a.V[i] >= b.V[i];
	return o;
}
template <size_t D, typename T1, typename T2>
inline vector<bool, D>operator<=(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<bool, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = a.V[i] <= b.V[i];
	return o;
}
template <size_t D, typename T1, typename T2>
inline vector<bool, D> operator&&(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<bool, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = a.V[i] && b.V[i];
	return o;
}
template <size_t D, typename T1, typename T2>
inline vector<bool, D> operator||(const vector<T1, D>& a, const vector<T2, D>& b) noexcept {
	vector<bool, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = a.V[i] || b.V[i];
	return o;
}
template<size_t D, typename T>
inline vector<T, D> operator-(const vector<T, D>& v) noexcept {
	vector<T, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = -v.V[i];
	return o;
}
template<size_t D, typename T>
inline vector<bool, D> operator~(const vector<T, D>& v) noexcept {
	vector<bool, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = !v.V[i];
	return o;
}
template<size_t D, typename T>
inline bool operator!(const vector<T, D>& v) noexcept {
	return !(_and(v));
}

// ------------ vector2 Logic ------------
template<typename T>
inline T cross(const vector2<T>& a, const vector2<T>& b) noexcept {
	return a.x * b.y - a.y * b.x;
}
// ------------ vector3 Logic ------------
template<typename T>
inline vector3<T> cross(const vector3<T>& a, const vector3<T>& b) noexcept {
	return vector3<T>(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
// ------------ Generic Logic ------------
template <typename T, size_t D>
inline bool _and(const vector<T, D>& v) noexcept {
	for (size_t i = 0; i < D; ++i) if(!v.V[i]) return false;
	return true;
}
template <typename T, size_t D>
inline bool _or(const vector<T, D>& v) noexcept {
	for (size_t i = 0; i < D; ++i) if (v.V[i]) return true;
	return false;
}
template <typename T, size_t D>
inline T summation(const vector<T, D>& v) noexcept {
	T sum = 0;
	for (size_t i = 0; i < D; ++i) sum += v.V[i];
	return sum;
}
template <typename T, size_t D>
inline vector<T, D> normal(const vector<T, D>& v) noexcept {
	auto m = magnitude(v);
	if (m == 0) return {};
	return v / vector<T,D>(m);
}
template <typename T, size_t D>
inline T dot(const vector<T, D>& a, const vector<T, D>& b) noexcept {
	return summation(a * b);
}
template <typename T, size_t D>
inline T magnitude(const vector<T, D>& v) noexcept {
	return (T)sqrt(magnitude2(v));
}
template <typename T, size_t D>
inline T magnitude2(const vector<T, D>& v) noexcept {
	return (T)summation(v * v);
}

#ifdef STAMP_MATH_vector_SHORT_NAMES
template <typename T, size_t D>
inline T sum(const vector<T, D>& v) noexcept {
	return summation(v);
}
template <typename T, size_t D>
inline T mag(const vector<T, D>& v) noexcept {
	return magnitude(v);
}
template <typename T, size_t D>
inline T mag2(const vector<T, D>& v) noexcept {
	return magnitude2(v);
}
template <typename T, size_t D>
inline vector<T, D> norm(const vector<T, D>& v)	noexcept {
	return normal(v);
}
#endif

template <size_t D, typename T1, typename T2>
inline vector<bool, D> equal_aprox(const vector<T1, D>& a, const vector<T2, D>& b) {
	vector<bool, D> o;
	for (size_t i = 0; i < D; ++i) o.V[i] = equal_aprox(a.V[i], b.V[i]);
	return o;
}
#if defined(STAMP_MATH_ALGORITHM_SHORT_NAMES) || defined(STAMP_MATH_vector_SHORT_NAMES)
template <size_t D, typename T1, typename T2>
inline vector<bool, D>	eq_e(const vector<T1, D>& a, const vector<T2, D>& b) {
	return equal_aprox(a, b);
}
#endif

#ifdef STAMP_OSTREAM_HEADER_INCLUDED
template <typename T, size_t D>
inline std::ostream& operator<<(std::ostream& stream, const vector<T, D>& v) {
	stream << "(";
	for (size_t i = 0; i < D; ++i) {
		stream << v.V[i];
		if(i != D - 1) stream << ", ";
	}
	stream << ")";
	return stream;
}
#endif

#ifdef STAMP_STRING_HEADER_INCLUDED
template <typename T, size_t D>
inline std::string to_string(const vector<T, D>& v) {
	using std::to_string;

	std::string result = "(";
	for (size_t i = 0; i < D; i++) {
		result += to_string(v.V[i]);
		if (i != D - 1) result += ", ";
	}
	result += ")";
	return result;
}
#endif

template<typename T> inline const vector2<T> vector<T, 2>::UNIT = vector2<T>(1);
template<typename T> inline const vector2<T> vector<T, 2>::UP = vector2<T>(1, 0);
template<typename T> inline const vector2<T> vector<T, 2>::DOWN = vector2<T>(-1, 0);
template<typename T> inline const vector2<T> vector<T, 2>::RIGHT = vector2<T>(0, 1);
template<typename T> inline const vector2<T> vector<T, 2>::LEFT = vector2<T>(0, -1);

template<typename T> inline const vector3<T> vector<T, 3>::UNIT = vector3<T>(1);
template<typename T> inline const vector3<T> vector<T, 3>::UP = vector3<T>(1, 0, 0);
template<typename T> inline const vector3<T> vector<T, 3>::DOWN = vector3<T>(-1, 0, 0);
template<typename T> inline const vector3<T> vector<T, 3>::RIGHT = vector3<T>(0, 1, 0);
template<typename T> inline const vector3<T> vector<T, 3>::LEFT = vector3<T>(0, -1, 0);
template<typename T> inline const vector3<T> vector<T, 3>::FORWARD = vector3<T>(0, 0, 1);
template<typename T> inline const vector3<T> vector<T, 3>::BACK = vector3<T>(0, 0, -1);

template<typename T> inline const vector4<T> vector<T, 4>::UNIT = vector4<T>(1);
template<typename T> inline const vector4<T> vector<T, 4>::UP = vector4<T>(1, 0, 0, 0);
template<typename T> inline const vector4<T> vector<T, 4>::DOWN = vector4<T>(-1, 0, 0, 0);
template<typename T> inline const vector4<T> vector<T, 4>::RIGHT = vector4<T>(0, 1, 0, 0);
template<typename T> inline const vector4<T> vector<T, 4>::LEFT = vector4<T>(0, -1, 0, 0);
template<typename T> inline const vector4<T> vector<T, 4>::FORWARD = vector4<T>(0, 0, 1, 0);
template<typename T> inline const vector4<T> vector<T, 4>::BACK = vector4<T>(0, 0, -1, 0);
template<typename T> inline const vector4<T> vector<T, 4>::ANA = vector4<T>(0, 0, 0, 1);
template<typename T> inline const vector4<T> vector<T, 4>::KANA = vector4<T>(0, 0, 0, -1);

STAMP_MATH_NAMESPACE_END

#endif